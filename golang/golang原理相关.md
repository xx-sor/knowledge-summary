## 1. GC
### 三色标记法
将程序中的对象分成白色 黑色 和灰色三类：

白色：潜在的垃圾，可能会被回收

黑色：活跃的对象，不会被回收

灰色：活跃的对象，有指向白色对象的指针

### gc过程
开始垃圾回收时，不存在任何的黑色对象，会把根对象(不需要其他对象就可以访问到的对象：全局对象 栈对象)标记成灰色，垃圾回收只会从灰色的集合中取出对象开始扫描，当没有一个灰对象时标记阶段结束。

具体的扫描逻辑是： 
(1) 从灰对象集合中选择一个灰色并标记成黑色；将黑对象指的所有对象都标记成灰色，来保证不会被回收，然后重复直到灰对象集合中没有灰对象
(2) 然后清理所有的白对象但是垃圾标记和正常程序是同时进行，所以有可能出现标记错的情况，比如扫描了a 以及a所有的子节点后，这时候用户建立了a指向b的引用，这时b是白色会被回收，所以引入了屏障。它可以在执行内存相关操作时遵循特定的约束，在内存屏障执行前的操作一定会先于内存屏障后执行的操作。屏障有两种，写屏障和读屏障，因为读屏障需要在读操作中加入代码，对性能影响大，所以一般都是写屏障。

#### 写屏障
业界有两种写屏障 ： 插入写屏障和删除写屏障 1.7用的插入写屏障 1.8用的混合写屏障
(1) 插入写屏障： 当A对象从A指向B改成从A指向C时，把BC都改成灰色。
(2) 删除写屏障：在老对象的引用被删除时，将白色的老对象改成灰色
(3) 混合写屏障 ：将被覆盖的对象标记成灰色 & 没有被扫描的新对象也被标记成灰色 & 将创建的新对象都标记成黑色
(屏障必须遵守三色不变性 ： 强三色不变性:黑色对象不会指向白对象，只会指向灰色对象或者黑色对象 弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由的多个白色对象的可达路径)

#### 垃圾回收阶段 ：
stw
开启写屏障
stw结束
扫描根对象
依次处理灰对象
关闭写屏障
清理所有白对象
垃圾回收触发条件
用户触发 runtime.gc
堆内存比上次垃圾回收增长100%
离上次垃圾回收超过2min

参考文档 : [内存分配](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/)


## 2.内存结构
内存管理的基本单元是mspan，他管理着一连串的页(8K),他会组成一个双向链表

### 构成
线程缓存(Thread Cache) ：属于每一个独立的线程，没有多线程，所以没有锁竞争，当线程缓存内存不够时，会使用中心缓存的内存。

中心缓存(Central Cache) : 这个需要互斥锁，他包含两个spanSet，用来存储包含空闲单元和不包含空闲单元的mspan，线程缓存从中心缓存获取内存的顺序是：清理过的，包含空闲空间的spanSet，没有被清理过的，有空闲空间的spanSet, 都没有找到从堆中申请新内存。

堆(Heap) ： 包含全局的中心缓存的列表central 和 管理堆区的内存区域的arenas，还有两颗二叉排序树 free 和 scav , free存放空闲非垃圾回收span(HeapIdle)， scav存放空闲已垃圾回收span。

### 内存分配策略
根据需要分配的内存大小选择不同的处理策略，根据对象的大小将对象分为微对象(0-16B),小对象(16B-32KB),大对象(>32KB)

微对象:先使用微型分配器，依次尝试线程缓存，中心缓存和堆 来分配内存。微型分配器可以将多个较小的内存分配请求合入一个内存块里，当内存块里所有的对象都要被回收时，整个内存块才能被回收。

小对象:依次尝试线程缓存，中心缓存和堆 来分配内存。确定分配对象的大小以及spanClass(有67种，每一种规定了特定大小，mspan的个数)

大对象: 直接在堆上分配内存，计算该对象需要的页数，按照一页(8K)的倍数在堆上申请内存

## 3.channel
不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存

#### channel 数据结构：
元素个数(qcount)； 循环队列长度(dataqsiz)；缓冲区数据指针(buf)；发送操作处理到的位置(sendx)；接收操作处理到位置(recvx)

#### channel 发送数据原理 （ch<- i）：
(1)加锁(如channel已关闭会报错)
(2)当存在等待接收者时，会直接发送。直接发送过程是 ：将发送的数据直接**拷贝**到接收变量的内存地址上； 把等待接收数据的goroutine 设置成grunnable(可运行状态)，并把该g放到发送方所在的处理器的runnext上等待执行，该处理器在下一次调度时会立刻唤醒数据的接收方
(3)当缓冲区存在空余空间时，将发送的数据写入channel的缓冲区(sendx)
(4)当不存在缓冲区或者缓冲区已满的时候，等待其他goroutine 从channel接收数据

#### channel 接收数据
(1)如果channel中数据为空，挂起当前g
(2)如果channel 已关闭且缓冲区没有数据，直接返回
(3)如果sendq 队列存在已经挂起的g，会将数据拷贝到接收变量所在的内存空间，并将
sendq队列中的g的数据拷贝到缓冲区

如果channel 的缓冲区包含数据，直接读取 接收操作处理到位置recvx对应的数据

在默认情况下会挂起当前的g，并将sudog结构加入队列并陷入休眠等待调度器的唤醒

map
使用拉链法解决hash碰撞问题

数据结构
hmap:可以理解是一个hash槽

count 当前哈希表中的元素数量 ；

B表示当前哈希表持有的bucket的数量。但是因为哈希表中桶的数量都是2的倍数，所以该字段会存储对数，即len(buckets) == 2^B

hash0 是哈希的种子，他能为hash函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；

oldbuckets 是哈希在扩容时用于保存之前 buckets的字段 ，它的大小是当前buckets的一半

buckets ： bmap的list，

bmap: buckets 中的值，每一个bmap都能存储8个键值对，当哈希表中存储的数据过多，的那个桶已经装满时就会使用 extra中桶存储溢出的数据，这两种不同的桶在内存中连续存储的。数据结构主要包含一个简单的tophash结构，存储了键的hash的高8位，通过对比不同键的哈希的高8位可以减少访问键值对次数以提高性能。不过溢出桶只是临时方案，创建过多的溢出桶最终也会导致hash的扩容

创建map
计算hash占用的内存是否溢出

获取一个随机的hash种子

计算需要的最小需要桶的数量

创建用于保存桶的数组，根据B 计算出需要创建的桶数量并在内存中分配一段连续的空间用户存储数据，

读写,扩容操作
读取 : 通过hash表设置的hash函数和种子获取当前键对应的hash，再拿到该键值对所在的桶序号(hash最低几位)和hash高位的8位数字。然后会依次遍历正常桶和溢出桶的数据，先比较hash的高8位和桶中存储的tophash，后比较传入的值和桶中的值以加速数据读写。用于选择桶序号的是hash的最低几位，用于加速访问的是hash高8位，这种设计避免同一个桶中有大量相等的tophash,

写入： 先读取，如果键值对的hash不存在，会为新键值对规划存储的内存地址

扩容 ： 在一下两种情况会触发hash的扩容 1 装载因子 > 6.5 ; (装载因子 = 元素数量/桶数量 ) 2 hash使用了太多溢出桶

如果这次扩容是溢出桶太多导致的，就是等量扩容 ，否则就是翻倍扩容 。

扩容
创建一组新桶和预创建的溢出桶，然后将原有的桶数组设置到oldbuckets上，将新的空桶设置到buckets上，溢出桶也用了相同逻辑。如果等量扩容，旧桶和新桶是1对 1 关系，当翻倍扩容时，每个旧桶元素会分流到新创建的2个桶中，比如扩容前桶号是3(11) 扩容后分流到3(011)和7(111)。
当hash表处于扩容状态时，每次写入或删除都会触发增量拷贝

遍历 ： 会引入一个随机数来随机选择一个遍历桶的位置，会先选一个正常桶开始遍历，然后遍历所有的溢出桶，然后依次按照索引顺序遍历其他桶

sync map
golang map是协程不安全的，sync.map是协程安全的，采用读写分离的方式降低锁粒度，适用于读多写少的场景，对于写多的场景会导致read map缓存失效，需要加锁，导致冲突变多

数据结构
mu 互斥锁 ;

read 存储读的数据，只读，所以并发安全，每次读写的时候golang都会吧类型转换成readOnly

readOnly 里面是一个map结构个一个标记和drity数据是否相同的字段，misses 计数用的，每次从read里读取失败 +1 ; drity 包含最新写入的数据，当misses打到一定值，将dirty赋值给read

读取，存储，删除
读取 ： 读read表 如果没读到并且 drity结果一样，就返回结果。否则就加锁，然后再读read，如果还是没读到并且和drity结果不一样，就读drity，然后misses++，然后解锁。这里在要做一次判断是害怕之前的判断和加锁操作是非原子的。
中间这个misses的值如果比 dirty的长度长，就会吧drity的值赋给read ，drity置为空，misses置为0

存储 ：如果存在并且没有标记成已删除，就直接返回，否则先查询read，如果标记为以删除，就把值加入到drity中，更改指针的值。如果read里不存在的话，先看dirty和read里数据是否相同 如果相同就再判断drity是不是nil，如果是nil，就会遍历read中的值赋给drity，并且把此时为nil的key置为已删除。然后再重置read。 如果不同就把值放到drity里。整个这个过程会加锁。

删除：先读read，如果读到，则把read的值置为空，如果没读到并且和drity值不一致就会加锁，然后再读read，如果结果还是没读到且和dirty值不一致，就会删除dirty里的值，是吧Entery的值置为nil，然后解锁。

select
让goroutine 同时等待多个channel可读或可写，在多个channel状态改变前，select会一直阻塞当前goroutine。select里的case中的表达式必须都是channel的收发操作

现象
1.select能在channel上进行非阻塞的收发操作(利用default)

2.select 在遇到多个channel同时相应时，会随机执行一种情况(为了避免饥饿问题)

实现原理
根据select语句情况优化语句
● select不存在任何case ： 直接阻塞
● select只存在一个case ： 编译器会改写成if
● select仅包含两个case，其中一个是的default ： 编译器认为是一次非阻塞收发操作
● 普通情况 ： 通过selectgo 获取执行case的索引，并通过多个if执行对应case的代码

随机生成一个遍历的轮询顺序pollOrder并根据channel地址生成加锁顺序lockOrder

根据pollOrder 遍历所有的case看是否有立刻可以处理的channel
如果存在，直接获取case对应的索引并返回
如果不存在，将当前goroutine加入到channel的收发队列，并挂起当前Goroutine

当调度器唤醒当前goroutine时，按照lockOrder遍历所有case，查找需要被处理的索引

defer
原理&处理方式
堆分配(早期，兜底)，栈分配（1.13，节省开销），开放编码(1.14)

堆分配： 编译期间将defer关键字转换成 deferproc 函数(负责创建新的延迟调用)，在调用defer函数的结尾插入deferreturn 函数(负责在函数调用结束时执行所有的延迟调用),运行时调用deferproc会将一个新的_defer结构体(包括参数和结果的内存大小 ，栈指针和调用方程序计数器，defer传入的函数等等)追加到当前goroutine的链表头，运行时调用deferreturn 会从链表取出该结构体并依次执行

栈分配 ： defer在函数体中最多执行一次时，会将defer结构体分配到栈上并调用

开放编码 ： 编译期间根据defer 和return 的个数判断是否开启开放编码优化，如果defer的执行可以在编译期间确定，会在函数返回前直接插入相应代码，否则由运行时的deferreturn处理

panic和recover
panic能够改变程序的控制力，调用panic后会立刻停止执行当前函数的剩余代码，并在当前goroutine中递归执行调用方的defer recover 可以中止panic造成的程序崩溃，他是一个只能在defer中发挥作用的函数

panic原理
将panic和recover转换成 gopanic和gorecover函数

运行过程中遇到gopanic方法，会将goroutine的链表中依次取出 _defer结构体并执行

如果执行延迟函数时遇到了gorecover : 在这次调用结束后 gopanic会从 _defer结构体中取出程序计数器和栈指针恢复程序；并跳回 deferproc，再跳回deferreturn并恢复正常流程

如果没有遇到gorecover就会依次遍历所有_defer,并最后调用 fatalpanic 中止程序打印panic的参数并返回错误码

interface
空的interface ： eface
_type 字段：指向一个运行时类型信息的结构体 。 size，ptrdata 表示interface对象的类型信息，hash 哈希值，用于map，
align 和 fieldalign 用与内存对齐，kind 类型的种类(bool int )，equal ： 判断是否相等 ，gcData ： 垃圾回收数据，
Data ：内存指针，指向interface 实例对象信息的存储地址，可以获取对象的具体属性的信息

非空的interface 数据结构 ： iface 。关键数据结构是
data ：同eface
tab ： itab ： inter ： 指向接口类型本身信息的指针，_type : 指向具体类型信息的指针 fun： 数组，指向实现接口的具体类型方法的指针

make和new
new用于分配内存，会返回类型的指针，值会被初始化为”0“ make仅用于分配和初始化slice、map、channel类型的对象，3种类型都是结构，返回类型是结构不是指针。

锁
sync.Mutex
数据结构

state 互斥锁的状态

sema 控制锁状态的信号量组成，默认情况下，互斥锁的状态位都是0 ，state 的int32中不同的位代表了不同的状态

mutexLocked表示互斥锁的锁定状态

mutexWoken 表示是否有被唤醒的goroutine

mutexStraving 当前互斥锁进入饥饿状态

waitersCount 当前互斥锁上等待的goroutine个数

饥饿模式是1.9 引入的优化，正常情况下锁的等待者会按照先进先出的顺序获取锁，但是刚被唤起的goroutine 与新创建的goroutine竞争时，大概率获取不到锁，为了减少这种情况，一旦goroutine超过1ms没有获取到锁，该g就会把锁切换到饥饿模式，在饥饿模式中，互斥锁会直接交给等待队列最前面的goroutine，新的goroutine在该状态下只会在队列末尾等待，如果一个goroutine获得了互斥锁并且它在队列的末尾或者它等待时间<1ms,当前互斥锁就会切回正常状态

加锁过程 ：

如果互斥锁处于初始化状态，会通mutexLocked 加锁如果互斥锁处于 mutexLocked 状态并在普通模式下工作，会进入自旋，执行30次PAUSE指令消耗cpu时间等待锁的释放

如果当前goroutine等待锁的时间超过1ms，互斥锁就会切换到饥饿模式，
互斥锁在正常情况下会尝试获取锁的goroutine切换至休眠状态，等待锁的持有者唤醒

如果当前goroutine是互斥锁上的最后一个等待的协程或者等待的时间小于1ms，那么它会将互斥锁切回正常模式

解锁过程：

当互斥锁已经被解锁时，调用unlock会直接抛出异常

当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置mutexLocked标志位

当互斥锁处于普通模式时，如果没有goroutine等待锁的释放或者已有被唤醒的goroutine获取了锁，会直接返回，否则会唤醒当前goroutine

sync.RWMutex
数据结构

w (mutex)复用互斥锁的能力；

writerSem readerSem 用于写等待读和读等待写的信号量，readerCount 存储了当前正在执行的读操作数量，readerWait 表示当前写操作被阻塞时等待的读操作个数

获取写锁时(rwmutex.lock)

调用mutex的lock阻塞后续操作

给readerCount - rwmutexMaxReaders（2^30）阻塞后续读操作3 如果有其他goroutine持有互斥锁的读锁，该g会进入休眠等待所有读锁持有者执行结束后释放writerSem将其唤醒

写锁释放(rwmutex.ulock)

将readerCount 变会正数，释放读锁

for循环释放所有因为获取读锁而陷入等待的goroutine

调用mutex.unlock 释放写锁

获取读锁(rwmutex.rlock) ：
readerCount ++；

如果该值为负数，则其他g获取了写锁，该g就会陷入休眠等待锁的释放

非负数，则获取成功

释放读锁(rwmutex.RUnlock) : readerCount--
1.如果返回值>=0 则解锁成功
2.如果<0，则说明有正在执行的写操作，则会减少readerWait 并在所有读操作后释放触发写操作的信号量writerSem，该信号量被触发后，会尝试唤醒尝试获取写锁的g

WaitGroup
等待一组goroutine的返回，使用waitgroup 将原本顺序执行的代码在多个goroutine中并发执行，加快速度 数据结构： noCopy 保证不会被开发者通过再赋值的方式拷贝；state1 存储状态和信号量

反射
反射机制就是通过来获取对象的类型信息或者结构信息，再进行访问和修改的能力。

反射3定律：
1.从interface{}变量可以反射出反射的对象
2.从反射对象可以获取interface{}变量
3.要修改反射对象，其值必须可设置

切片和数组
数组
是一种有固定长度的基本数据结构，一旦创建就不影响改变长度。数组是值拷贝传递。数组中的元素小于等于4个，所有的变量会在栈上初始化，否则会在静态存储区初始化，然后拷贝到栈上

切片
slice本身是一个特殊的引用类型，自身是一个结构体，属性len表示可用元素数量，读写操作不能超过这个限制，cap表示最大扩张容量。如果slice在append时容量超过cap 会触发扩容 分配一个容量翻倍的内存 不再影响原有内存
切片初始化问题： 切片初始化的时候 如果不设置cap cap会为0，如果之后频繁append 会触发多次扩容，可以预先设置一个cap 比如1024

内存逃逸
在函数内部分配的变量，由于某些原因生命周期被延长，必须在堆上分配，而不是栈上。

分析逃逸：go build -gcflags -'m'

可能带来的影响
1.堆上分配内存慢
2.垃圾回收压
3.有可能内存泄露

内存逃逸可能情况
1.函数返回局部指针：函数返回一个局部变量的指针时，这个变量就会发生逃逸，因为局部变量生命周期本来应该在这个函数结束时结束，但是返回指针代表外部也能访问他
res会逃逸到堆上

func Add(x,y int)*int{
	res := 0 
	res =x+y 
	return &res
}
动态分配逃逸 ： 当通过make new 动态分配内存时，尤其是编译器无法确定大小时

funcmakeSlice(sizeint)[]int{
	s:=make([]int,size)
	return s
}
interface{} 类型逃逸 ： 当一个具体的变量被赋值给一个interface类型时，编译器没法确定具体类型

str:="aaaaa"
fmt.Println("%v",str)
闭包引用逃逸 ：闭包引用了他的外部函数的局部变量 这个局部变量本来应该在函数返回时结束，但是由于闭包，这个局部变量需要在函数执行完毕后还是可用

func a() func() int {
	x:= 100
    return func() int {
		x++
        returnx
    }
}
