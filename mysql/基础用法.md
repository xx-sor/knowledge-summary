## 1.COUNT(1) 和 COUNT(*)的有区别么？
在 MySQL 中，COUNT(1) 和 COUNT(*) 都是用来计算表中行的数量的聚合函数。在实践中，它们通常可以互换使用，并且在大多数情况下，它们的性能是相同的。这是因为数据库优化器足够智能，可以识别这两个函数实际上在执行相同的操作。

COUNT(*) 会计算表中所有行的数量，不管列中的值是否为 NULL。

COUNT(1) 本质上与 COUNT(*) 相同，因为数字 1 不是一个列名或列的值，它只是一个数字常量。数据库优化器将识别这一点，并且在内部将其优化为与 COUNT(*) 相同的操作。

在 SQL 标准中，COUNT(*) 被指定为特别的计数功能，它不关心任何特定的列，而是简单地计数行。因此，COUNT(*) 是更符合 SQL 标准的方式来计数表中的行数。

在早期的数据库系统中，可能会有一些性能差异，因为 COUNT(1) 或 COUNT(column) 可能会导致数据库检查具体的列值或常量。但是，在现代数据库系统中，这种差异通常已经被优化器的智能处理所消除。

总结一下，COUNT(1) 和 COUNT(*) 在 MySQL 中的区别主要是语义上的，而不是性能上的。使用 COUNT(*) 是计数行数的更通用和标准的方法。

## 2.分页查询（查询条件只带了非聚簇索引没带聚簇索引的情况）
```
SELECT * FROM wechat_ecommerce_merchant_info ORDER BY create_time ASC LIMIT 5000000, 10;

```
LIMIT 5000000, 10 表示查询将跳过前 5000000 行，然后返回接下来的 10 行。

### 大offset带来的性能问题
前提依然是讨论查询条件只带了非聚簇索引没带聚簇索引的场景
性能问题：对于大表来说，使用高 offset 值可能会导致性能问题，因为数据库需要扫描和跳过大量的行。可以考虑使用其他分页方法来提高性能，例如基于索引的分页。
### 原理
[mysql分页原理](https://blog.csdn.net/qq_34115899/article/details/120727513)
总结：
(1)多用exlpain分析sql性能
(2)mysql分为server层和存储层:
server层负责处理一些通用的事情，诸如连接管理、SQL语法解析、分析执行计划之类的东西
存储引擎层负责具体的数据存储，诸如数据是存储到文件上还是内存里，具体的存储格式是什么样的之类的。我们现在基本都使用InnoDB存储引擎，其他存储引擎使用的非常少了，所以我们也就不讨论其他存储引擎了。
(3)server层向存储层要记录，是一条一条要的。
流程是：非聚簇索引->聚簇索引->找到叶子节点的记录
MySQL是在server层准备向客户端发送记录的时候才会去处理limit子句中的内容。因此对于这个语句：
```
select * from demo_info order by key1 limit 10000, 1;

```
有2种处理方案：
全表扫描 or 使用非聚簇索引。
如果使用索引，server层会向存储层要10001条数据（非聚簇索引只会走一次，回表是10001次），前10000次要到后server层都发现不满足limit，就不返回给客户端。因此mysql认为这样的性能还不如全表扫描。
因此实际上mysql在这里会选择全表扫描+filesort的方式。全表扫描+filesort就是把聚集索引中的记录都依次与给定的搜索条件进行比较，把符合搜索条件的记录再进行排序，MySQL认为这样操作的成本比多次回表成本低。
MySQL是根据成本来选择对应索引查询的，如果你不知道成本怎么计算，可以看[MySQL查询为什么选择使用这个索引？——基于MySQL8.0.22索引成本计算](https://blog.csdn.net/qq_34115899/article/details/120217907)
如果不理解全表扫描和聚集索引，见这里：[一条SQL如何被MySQL架构中的各个组件操作执行的？](https://blog.csdn.net/qq_34115899/article/details/130270929)


#### 替代方案
##### 方案一
先搜主键，再通过主键范围搜索+限制数量+再排序。
```
SELECT * FROM wechat_ecommerce_merchant_info
WHERE id > (SELECT id FROM wechat_ecommerce_merchant_info ORDER BY create_time ASC LIMIT 1 OFFSET 5000000)
ORDER BY create_time ASC
LIMIT 10;

```
这个`id`字段是主键。
因为非聚簇索引的叶子节点上就有主键，这样可以不用回表。

##### 方案二
在不严格要求分页要用非聚簇索引排序的情况下，直接用主键作为查询条件来查，不要用非聚簇索引。
这样的坏处是如果主键更新（有新数据插入），分页可能会造成重复或者遗漏。

## 3.联表查询和相关子查询的区别
例：
```SQL
# 员工表
id | name   | department_id
---|--------|---------------
1  | Alice  | 1
2  | Bob    | 2
3  | Carol  | 1
4  | Dave   | 3

# 部门表
id | name
---|--------
1  | Sales
2  | HR
3  | IT

# 要查员工和其所在的部门名
# 相关子查询，相关指的是子查询的条件依赖外部查询（用到了employees.department_id，而外部的查询正是查employees表）
SELECT name,
       (SELECT name
        FROM departments
        WHERE departments.id = employees.department_id) AS department_name
FROM employees;

# 联表查询
SELECT employees.name, departments.name AS department_name
FROM employees
JOIN departments ON employees.department_id = departments.id;

```
以下探讨分别的查询原理

### 相关子查询原理
步骤：
#### (1)初始化外部查询：
生成内部结果集：[(1, 'Alice', 1), (2, 'Bob', 2), (3, 'Carol', 1), (4, 'Dave', 3)]
原sql语句只查name，为什么这步会把department_id一起查出来？
#### DBMS内部优化
数据库系统在解析和执行SQL查询时，会进行以下几步：
①解析（Parse）：将SQL语句解析为内部表示形式：
数据库系统会解析整个SQL查询，识别出主查询和子查询。
本例：识别出外部查询 SELECT name FROM employees 和相关子查询 SELECT name FROM departments WHERE departments.id = employees.department_id
②优化（Optimize）：生成最优的执行计划。这一步会考虑索引、统计信息和其他优化策略：
本例：**数据库系统会分析查询，发现子查询依赖于外部查询的 department_id 列。为了有效地执行子查询，数据库系统会确保在执行外部查询时保留必要的上下文信息（如 department_id）。**
③执行（Execute）：根据生成的执行计划执行查询，生成结果集：
本例：**数据库系统在执行外部查询时，会根据优化后的执行计划获取 employees 表的 name 和 department_id 列，尽管原始查询只请求了 name 列。**

#### (2)**逐行**处理外部查询结果集：
对于 name = 'Alice'：
使用 department_id = 1 执行子查询 SELECT name FROM departments WHERE departments.id = 1。
返回结果：Sales
合并结果：('Alice', 'Sales')

对于 name = 'Bob'：
使用 department_id = 2 执行子查询 SELECT name FROM departments WHERE departments.id = 2。
返回结果：HR
合并结果：('Bob', 'HR')

对于 name = 'Carol'：
使用 department_id = 1 执行子查询 SELECT name FROM departments WHERE departments.id = 1。
返回结果：Sales
合并结果：('Carol', 'Sales')

对于 name = 'Dave'：
使用 department_id = 3 执行子查询 SELECT name FROM departments WHERE departments.id = 3。
返回结果：IT
合并结果：('Dave', 'IT')

#### (3)合并结果
合并结果为：
```SQL
name  | department_name
------|-----------------
Alice | Sales
Bob   | HR
Carol | Sales
Dave  | IT
```


### 联表查询原理
步骤：
#### (1)构建笛卡尔积
构建笛卡尔积：
笛卡尔积（Cartesian Product）是两个表中所有行的组合。在构建笛卡尔积时，每一行会与另一表中的每一行组合，形成一个新的结果集。
生成 employees 和 departments 表的所有可能组合:
```
笛卡尔积 (Cartesian Product):

employees.id | employees.name | employees.department_id | departments.id | departments.name
-------------|----------------|-------------------------|----------------|-----------------
1            | Alice          | 1                       | 1              | Sales
1            | Alice          | 1                       | 2              | HR
1            | Alice          | 1                       | 3              | IT
2            | Bob            | 2                       | 1              | Sales
2            | Bob            | 2                       | 2              | HR
2            | Bob            | 2                       | 3              | IT
3            | Carol          | 1                       | 1              | Sales
3            | Carol          | 1                       | 2              | HR
3            | Carol          | 1                       | 3              | IT
4            | Dave           | 3                       | 1              | Sales
4            | Dave           | 3                       | 2              | HR
4            | Dave           | 3                       | 3              | IT

```

##### 优化
笛卡尔积如果全量生成有几个问题：
①性能消耗：笛卡尔积的复杂度是 O(m * n)，其中 m 和 n 分别是两个表的行数。对于大表，生成所有可能的行组合会非常耗时。
②内存消耗：生成笛卡尔积会产生一个非常大的中间结果集，可能会占用大量内存。当内存不够用时，还需要使用到磁盘，还会增加io。

内部优化：
①查询优化器：数据库系统的查询优化器会生成最优的执行计划，避免不必要的笛卡尔积计算。例如，优化器可能会在构建笛卡尔积前先应用过滤条件，以减少中间结果集的大小。
②数据库系统会分块处理数据或使用流式处理（逐行生成和处理笛卡尔积，而不是一次性生成整个结果集）来减少内存占用。
③连接算法：数据库系统可以选择合适的连接算法（如嵌套循环连接、哈希连接、合并连接）以优化生成笛卡尔积的性能。

#### (2)应用连接条件
应用连接条件：使用 ON employees.department_id = departments.id 过滤组合，只保留满足条件的行：
```
连接条件应用后:

employees.id | employees.name | employees.department_id | departments.id | departments.name
-------------|----------------|-------------------------|----------------|-----------------
1            | Alice          | 1                       | 1              | Sales
2            | Bob            | 2                       | 2              | HR
3            | Carol          | 1                       | 1              | Sales
4            | Dave           | 3                       | 3              | IT

```

#### (3)选择返回列
选择列：选择 employees.name 和 departments.name 生成最终结果集:
```
最终结果集:

employees.name | departments.name
---------------|-----------------
Alice          | Sales
Bob            | HR
Carol          | Sales
Dave           | IT

```

### 比较结论
在大多数情况下，特别是数据量较大的情况下，使用join查询的性能优于使用相关子查询。


