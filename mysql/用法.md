## 1.COUNT(1) 和 COUNT(*)的有区别么？
在 MySQL 中，COUNT(1) 和 COUNT(*) 都是用来计算表中行的数量的聚合函数。在实践中，它们通常可以互换使用，并且在大多数情况下，它们的性能是相同的。这是因为数据库优化器足够智能，可以识别这两个函数实际上在执行相同的操作。

COUNT(*) 会计算表中所有行的数量，不管列中的值是否为 NULL。

COUNT(1) 本质上与 COUNT(*) 相同，因为数字 1 不是一个列名或列的值，它只是一个数字常量。数据库优化器将识别这一点，并且在内部将其优化为与 COUNT(*) 相同的操作。

在 SQL 标准中，COUNT(*) 被指定为特别的计数功能，它不关心任何特定的列，而是简单地计数行。因此，COUNT(*) 是更符合 SQL 标准的方式来计数表中的行数。

在早期的数据库系统中，可能会有一些性能差异，因为 COUNT(1) 或 COUNT(column) 可能会导致数据库检查具体的列值或常量。但是，在现代数据库系统中，这种差异通常已经被优化器的智能处理所消除。

总结一下，COUNT(1) 和 COUNT(*) 在 MySQL 中的区别主要是语义上的，而不是性能上的。使用 COUNT(*) 是计数行数的更通用和标准的方法。

## 2.分页查询（查询条件只带了非聚簇索引没带聚簇索引的情况）
```
SELECT * FROM wechat_ecommerce_merchant_info ORDER BY create_time ASC LIMIT 5000000, 10;

```
LIMIT 5000000, 10 表示查询将跳过前 5000000 行，然后返回接下来的 10 行。

### 大offset带来的性能问题
前提依然是讨论查询条件只带了非聚簇索引没带聚簇索引的场景
性能问题：对于大表来说，使用高 offset 值可能会导致性能问题，因为数据库需要扫描和跳过大量的行。可以考虑使用其他分页方法来提高性能，例如基于索引的分页。
### 原理
[mysql分页原理](https://blog.csdn.net/qq_34115899/article/details/120727513)
总结：
(1)多用exlpain分析sql性能
(2)mysql分为server层和存储层:
server层负责处理一些通用的事情，诸如连接管理、SQL语法解析、分析执行计划之类的东西
存储引擎层负责具体的数据存储，诸如数据是存储到文件上还是内存里，具体的存储格式是什么样的之类的。我们现在基本都使用InnoDB存储引擎，其他存储引擎使用的非常少了，所以我们也就不讨论其他存储引擎了。
(3)server层向存储层要记录，是一条一条要的。
流程是：非聚簇索引->聚簇索引->找到叶子节点的记录
MySQL是在server层准备向客户端发送记录的时候才会去处理limit子句中的内容。因此对于这个语句：
```
select * from demo_info order by key1 limit 10000, 1;

```
有2种处理方案：
全表扫描 or 使用非聚簇索引。
如果使用索引，server层会向存储层要10001条数据（非聚簇索引只会走一次，回表是10001次），前10000次要到后server层都发现不满足limit，就不返回给客户端。因此mysql认为这样的性能还不如全表扫描。
因此实际上mysql在这里会选择全表扫描+filesort的方式。全表扫描+filesort就是把聚集索引中的记录都依次与给定的搜索条件进行比较，把符合搜索条件的记录再进行排序，MySQL认为这样操作的成本比多次回表成本低。
MySQL是根据成本来选择对应索引查询的，如果你不知道成本怎么计算，可以看[MySQL查询为什么选择使用这个索引？——基于MySQL8.0.22索引成本计算](https://blog.csdn.net/qq_34115899/article/details/120217907)
如果不理解全表扫描和聚集索引，见这里：[一条SQL如何被MySQL架构中的各个组件操作执行的？](https://blog.csdn.net/qq_34115899/article/details/130270929)


#### 替代方案
##### 方案一
先搜主键，再通过主键范围搜索+限制数量+再排序。
```
SELECT * FROM wechat_ecommerce_merchant_info
WHERE id > (SELECT id FROM wechat_ecommerce_merchant_info ORDER BY create_time ASC LIMIT 1 OFFSET 5000000)
ORDER BY create_time ASC
LIMIT 10;

```
这个`id`字段是主键。
因为非聚簇索引的叶子节点上就有主键，这样可以不用回表。

##### 方案二
在不严格要求分页要用非聚簇索引排序的情况下，直接用主键作为查询条件来查，不要用非聚簇索引。
这样的坏处是如果主键更新（有新数据插入），分页可能会造成重复或者遗漏。

